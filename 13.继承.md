## 继承

继承是面向对象编程很重要的组成部分，可以显著减少代码重复。如果把合约看作是对象的话，solidity也是面向对象的编程，也支持继承。

#### 规则

- `virtual`：父合约中的函数，如果希望子合约重写，需要加上 `virtual`关键字。
- `override`：子合约重写了父合约中的函数，需要加上 `override`关键字。

#### 简单继承

我们先写一个简单的爷爷合约 `Yeye`，里面包含一个 `Log`事件和3个 `function`：`hip()`，`pop()`，`yeye()`，输出都是“Yeye”

```
contract Yeye {
	event Log(string msg);

	//定义3个function：hip()，pop()，yeye()，log值为Yeye。
	function hip() public virtual{
		emit Log("Yeye");
	}
	function pop() public virtual{
		emit Log("Yeye");
	}
	function yeye() public virtual{
		emit Log("Yeye")
	}
}
```

我们再定义一个爸爸合约 `Baba`，让他继承 `Yeye`合约，语法就是 `contract Baba is Yeye`，非常直观。在 `Baba`合约里，我们重写一下 `hip()`和 `pop()`这两个函数，加上 `override`关键字，并将它们输出改为 `"Baba"`；并且加一个新的函数 `baba`，输出也是 `"Baba"`。

```
contract Baba is Yeye{
	//继承两个function:hip()和pop(),输出改为Baba。
	function hip() public virtual override{
		emit Log("Baba");
	}
	function pop() public virtual override{
		emit Log("Baba");
	}
	function baba() public virtual override{
		emit Log("Baba");
	}
}
```

我们部署合约，可以看到 `Baba`合约里有4个函数，其中 `hip()`和 `pop()`的输出被成功改写成 `"Baba"`，而继承来的 `Yeye()`的输出仍然是 `"Yeye"`。

#### 多重继承

solidity的合约可以继承多个合约。规则：

继承时要按备份最高到最低的排序排。比如我们写一个 `Erzi`合约，继承 `Yeye`合约和 `Baba`合约，那么就要写成 `contract Erzi is Yeye,Baba`，而不能携程 `contract Erzi is Baba, Yeye`，不然就会报错。如果某一个函数在多个继承的合约里都存在，比如例子中的 `hip()`和 `pop()`，在子合约里面必须重写，不然会报错。重写在多个父合约中都重名的函数时，`override`关键字后面要加上所有父合约名字,例如 `override(Yeye,Baba)`。

```
contract Erzi is Yeye,Baba{
	// 继承两个function：hip()和pop()，输出值为Erzi
	function hip() public virtual override(Yeye, Baba){
		emit Log("Erzi");
	}
	function pop() public virtual override(Yeye,Baba){
		emit Log("Erzi");
	}
}
```

我们可以看到，`Erzi`合约里面重写了 `hip()`和 `pop()`两个函数，将输出改为 `"Erzi"`，并且还分别从 `Yeye`和 `Baba`合约继承了 `yeye()`和 `baba()`两个函数。

#### 修饰器的继承

solidity中的修饰器（`Modifier`）同样可以继承，用法与函数继承类似，在相应的地方加 `virtual`和 `override`关键字即可。

```
contract Base1 {
	modifier exactDividedBy2And3(UINT _a) virtual {
		require(_a % 2 == 0 && _a %3 == 0);
		_; 
	}
}
contract Identifier is Base1 {

	// 计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数
	function getExactDividedBy2And3(uint _devidend) public exactDividedBy2And3(_devidend) pure returns(uint, uint) {
		return getExactDividedBy2And3WithoutModifier(_devidend)
	}

	//计算一个数分别被2除和被3除的值
	function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returens(uint,uint){
		uint div2 = _dividend / 2;
		uint div3 = _dividend / 3;
		return (div2, div3);
	}
}
```

`Identifier`合约可以直接在代码中使用父合约中的 `exactDividedBy2And3`修饰器，也可以利用 `override`关键字重写修饰器：

```
	modifier exactDividedBy2And3(uint _a) override {
		_;
		require(_a % 2 == 0 && _a % 3 == 0);
	}
```

#### 构造函数的继承

子合约有两种方法继承父合约的构造函数。举个例子，父合约 `A`里面有一个状态变量 `a`，并由构造函数的参数来确定：

```
// 构造函数的继承
abstract contract A {
	uint public a;

	constructor(uint _a) {
		a = _a
	}
}
```

1. 在继承时声明父构造函数的参数，例如：`contract B is A(1)`
2. 在子合约的构造函数中声明构造函数的参数，例如：
